# 说明
这一节来介绍一下所有权机制。
所有权机制是实现内存管理的基石，首先来看看什么是作用域。
## 作用域
作用域可以理解为`{}`括号内包括的东西，实际上，内存管理指的是那些在编译器无法提前知道内容大小的东西，也就是存储在堆上的变量。
在`{}`内，一个堆上的变量是有效的，出去这个括号，其值就会自动被释放，我们来看看字符串`String`类型的值。
这是我们的源程序
```rust
// 1.所有权
    // 创建一个string类型的变量
    let s1 = String::from("hello");
    // 此时，我们把这个s1内容赋值给s2
    let s2 = s1;
    // 然后，我们打印一下s1
    println!("字符串内容为: {}", s1);
```
构建一下
```bash
cargo build
```
发现出错，这是因为`s2`已经拿走了属于这个字符串的控制权，从内存层面上来看，`s1`和`s2`实际上都一起指向了同一块内容，这也叫做浅拷贝，为了避免重复创建深拷贝，每次赋值后都会把原来的哪个指针失效，从而始终保证只有一个指针指向我们的数据

```rust
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:8:28
  |
4 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
5 |     // 此时，我们把这个s1内容赋值给s2
6 |     let s2 = s1;
  |              -- value moved here
7 |     // 然后，我们打印一下s1
8 |     println!("字符串内容为: {}", s1);
  |                                  ^^ value borrowed here after move
```

为什么栈上的一些变量不会有这种问题？官方的回答是栈上创建一个变量几乎不耗费多大时间，而堆则需要内存分配器去寻找可用内存并进行拷贝复制。栈上的变量还实现了一种特别的属性
> Rust 有一个叫做 Copy trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上（第 10 章详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 标注，将会出现一个编译时错误。要学习如何为你的类型添加 Copy 标注以实现该 trait，请阅读附录 C 中的 “可派生的 trait”。

