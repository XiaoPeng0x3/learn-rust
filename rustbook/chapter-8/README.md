# 说明
由于这部分内容不是特别多，但是还是有一些需要额外注意的点，所以来做一下说明。

# vector
`vector`可以说是我们相当熟悉的一个东西了，就是动态数组，下面来看看`vector`有哪些注意事项。

## vector的创建
`vector`的创建有两种创建方式，可以通过`new`来创建，也可以通过`vector`宏来创建

- 使用`new`的方式来创建
    有很多容器的`api`都是这样的形式，使用这个形式，我们就可以创建空的`vector`
    ```rust
        // 新建一个vector
        let mut v: Vec<i32> = Vec::new();
    ```
    这样创建出来的就是一个空的`vector`，我们可以通过调用`push`方法来添加一些元素.
    ```rust
        v.push(1);
    ```
- 使用宏的方式进行创建
    还可以使用`vector!`宏来创建
    ```rust
        let v2 = vec![1, 2, 3];
    ```

除了通用的`push`方法外，还有一个`get`方法，即传入对应的索引下标，即可返回对应的元素，但是`get`方法还做了一层封装，如果这个索引下标不合法，那么就会返回一个`None`值，我们需要对这个`None`值进行处理判断，使用`match`进行判断。
```rust
        // 2. 访问越界索引
    let x = v.get(100); // 这里会返回一个Option类型, 返回的是一个null值
    // 访问越界的索引会导致panic, 所以使用get方法来避免panic
    // 索引越界，则会导致panic
    match x {
        Some(val) => println!("v[100] = {}", val),
        None => println!("v[100] 越界了"),
    }
```
除此之外，还需要注意的就是所有权的问题，引用不涉及所有权的转移
```rust
        // 迭代访问
    for x in &v {
        println!("x = {}", x);
    }
```
还有就是引用元素后不可以再进行元素添加。
```rust
    let x = &v[0];
    v.push(5); // 这里会导致编译错误，因为x是一个不可变引用
```
不允许添加元素是因为，如果`v`因为空间不足而导致重新分配内存的话，原来的引用就会指向一个错误的地址。

## vector的一个技巧
众所周知啊，`vector`只能存储类型相同的元素，但是我们之前学习到了枚举类型，枚举类型可以对值进行绑定，这样，我们就可以通过枚举类型来起到一种可以添加任意元素的假象.....

# 字符串
字符串并不简单，还是有许多细节需要注意的，首先，字符串常量是`&str`类型的，存储在静态区，不会设计所有权的转移，而`String`类型是动态分配的，所以会涉及到所有权的转移，其类型是`&String`，不过有的时候这两个可以发生转换。

## 创建字符串
- `new`
    创建一个空的字符串

- `from`
    将字符串常量转为`String`类型的变量

- 直接创建字符串常量
    `let s = "abc";`

- 字符串常量转`String`类型
    `let s = "abc".to_string()`

## 遍历字符串
字符串的遍历只能通过迭代器的方式去遍历，因为 **`Rust`字符串不支持索引访问**,所以只能迭代器进行访问
```rust
    for c in s.chars() {
        // do...
    }

    for c in s.bytes() { // 字节流
        // do...
    }
```

上面我们说到，字符串不支持索引访问，这是因为有一些`unicode`字符串并不是单字节的，所以通过下标访问并不能获取到对应的字符，所以不支持下标访问。